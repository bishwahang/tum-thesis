%!TEX root = ../main.tex
\chapter{Methodology}\label{chapter:methodology}
In this chapter we will give overview of our system design and work flow.
First, in~\autoref{sec:Terminology}, we will give technical descriptions of terms we will be using to describe our work flow.
In~\autoref{sec:Work Flow}, we will describe the overall procedure of our research work.
\section{Terminology}
\label{sec:Terminology}
In this section we give a detailed description of different terms we will be using through out the report.
\subsection{Behavioral Profile}
\label{sub:Behavioral Profile}
\citeauthor{bayer} define \textbf{behavioral profile} as, ``the abstraction of a program's execution trace that provides information on the OS objects that the program operated on, along with the operations''.
OS Object refers to resource type such as file, registry or section, that could be modified or queried with the system calls.
System calls consisted of Windows NT, native API and the Windows API functions.\\

The behavioral profile was based on the execution traces of programs irrespective of order execution as reordering system calls could be done without changing the semantics of program~\cite[]{bayer}.
It consisted of a list of different operations operated on the different OS objects during the execution of binary.
The system calls that had same purpose as resultant output but different calling API name were generalized under single name---\emph{NtCreateProcess} and \emph{NtCreateProcessEx} would be generalized as, \emph{`create'} OS Operation for, \emph{`porcess'} OS object~\cite[]{bayer}.\\
\subsubsection{OS Objects}
\label{ssub:OS Objects}
OS Object were primarily the resource that were created, delete, modified during the program execution.
\citeauthor{bayer} define \emph{OS Objects} as:
\begin{lstlisting}[numbers=none]
OS Object ::= (type, object-name)
type ::= file|registry|process|job|
       network|thread|section|
       driver|sync|service|random|
       time|info
\end{lstlisting}
An OS Object consists of its type and object-name.
The type of OS Object are file, registry, process, job, network, thread, section, driver, sync, service, random, time, and info.
An object-name is the name of the OS object.
For an instance, \url{`c:\\ntlos.exe'} is an object-name for object type \emph{file}.

\subsubsection{OS Operations}
\label{ssub:OS Operations}
Broadly, OS Operation is the generalization of a system call.
\citeauthor{bayer} define \emph{OS Operations} as:
\begin{lstlisting}[numbers=none]
OS operation ::= (operation-name,
                opeartion-attributes?,
                successful?)
\end{lstlisting}
An OS operation object consists of name of the operation, any additional attributes, and the status of the operation whether it was successful or not.\\
A snippet of behavioral profile is shown in~\autoref{lst:bpsample} with sample of operations executed on OS Objects file, registry, and section.
\begin{lstlisting}[numbers=none,language=TeX,caption={Behvaioral Profile sample}, label={lst:bpsample}]
  op|file|`C:\\Program Files\\Common Files\\sumbh.exe'
   create:1
   open:1
   query:1
   write:1

  op|registry|`HKLM\\SOFTWARE\\CLASSES\\CLSID\\{00021401-000000000046}'
   open:1
   query:1
   query_value(''):1
   query_value('InprocServer32'):0

  op|section|`BaseNamedObjects\\MSCTF.MarshalInterface.FileMap.ELE.B.FLKMG'
   create:1
   map:1
   mem_read:1
   mem_write:1
\end{lstlisting}
To explain the behavioral profile shown in~\autoref{lst:bpsample}, \textit{`create'} operation for file OS object \url{`C:\\Program Files\\Common Files\\sumbh.exe'} was successful with success value 1, whereas \textit{`query\_value'} operation with operation-attribute value \emph{'InprocServer32'} for registry OS Object \url{`HKLM\\SOFTWARE\\CLASSES\\CLSID\\{00021401-000000000046}'} failed with success value 0. % chktex-file 8
\\

We had the ``behavioral profiles'' of the malware samples that we used to create new database which is described in~\autoref{sec:Creation of Database}.
Informations from \emph{OS Objects} and \emph{Operations} were used to extract resource activities (execution traces) of the malware (program).
% recreate the database of all the malware (program) samples and its resource activities (execution traces).

\subsection{Resource Type and Activities}
\label{sub:Resource Types and Activities}
As discussed before in~\autoref{ssub:OS Objects}, an OS Object, are representation of resource types.
For our research, we considered following 8 resource types into consideration, that could best determine the behavioral interference between malware.
We will give a short description of each resource type according to Microsoft Developers Network documentation~\cite[MSDN]{msdn}.
\subsubsection{File}
\label{ssub:File}
A \emph{file} is a means of storing resourceful information which can be retrieved or modified in future.
File objects function as the logical interface between kernel and user-mode processes and the file data that resides on the physical disk.
It not only holds the data written on the file but also a set of attributes maintained by the kernel for system purposes such as \emph{File name, Current byte offset, Share mode, I/O mode}~\cite[]{msfile}.\\
File type in the behavioral profile encompasses not only general file, but named pipe and mailslot resources.
% File is an important resource type for us to focus as our hypothesis for research is that malware of certain family creates or deletes a certain file to infect a system and this also could be used by malware of another family to remove its nemesis from system.
File is an important resource type as many malware creates or deletes file in order to infect the system or remove another malware from the system.
These file activities will be important behavior to find the interference between malware families.
\subsubsection{Registry}
\label{ssub:Registry}
A \emph{Registry} is a database defined by a system where different applications and system components store and retrieve data such as configurations settings for its use.
The data stored in the registry varies according to the version of Microsoft Windows.
Application performs the basic add, modify, retrieve, or delete operation in the registry through the registry API~\cite[]{msregistry}.\\
% We take the registry keys associated with the malware into consideration for experiment as it provides vital information on the behavior of a malware sample.
% Malware with same family might have similar registry key activity and also malware from different family might look for the particular registry key in the system in order to detect the presence of another family.
Registry keys provide vital information on malware type and behavior as we have seen in~\autoref{sec:Malware Types and Families} that different malware families create different registry keys when they infect a system.
Malware from same family modify specific registry key, which is used to detect their presence.
\subsubsection{Service}
\label{ssub:Service}
A \emph{Service} is a computer program that operates in system background, similar to UNIX daemon~\cite[]{servicedef}.
A \emph{service} can be started at system boot through the Service Control Panel, or an application can also use service functions such as \emph{StartService, OpenService, DeleteService} to configure services.
However, it must conform to the interface rules of Service Control Manager (SCM)~\cite[]{msservice}.\\
Malware can stop other services related to security or other malware, create a new service, or hook itself into autostart services.
These service related activity are thus interesting to study malware behavior and interaction with other malware.
\subsubsection{Section}
\label{ssub:Section}
A \emph{section} object is sharable memory which is used by process to share its memory address space (memory sections) with other processes.
It is also used by process to map a file into its memory address space~\cite[]{mssection}.\\
In case of behavioral profile, it broadly represents memory mapped files---file with content in virtual memory, enabling application and multiple processes to modify the file by reading and writing directly to the memory~\cite[]{memmapfile}.
\subsubsection{Process}
\label{ssub:Process}
A binary can spawn one or more \emph{processes}.
A \emph{process} is simply an instance of a computer program being executed that consists of instructions and current activity of program~\cite[]{msprocess}.\\
Malware trying to detect and kill the process created by another malware is interesting case of behavioral interference.
% Malware constantly looks for creation of some utility processes, such as \emph{Task Manager} or \emph{Virus Removal Tools}, and shuts it down, as soon as the process starts.
% Similar behavior of malware, to check for process created explicitly by other malware samples, will be a proof for behavioral interference between malware families.
\subsubsection{Job}
\label{ssub:Job}
A \emph{Job} object makes grouping of process as single unit to manage possible.
It can be named and shared securely to control attributes of processes grouped together and operation on a job makes the affect on all the process in its group~\cite[]{msjob}.
\subsubsection{Sync}
\label{ssub:Sync}
A \emph{sync object} is used to coordinate the execution of multiple threads as more than one process could share the handle of single synchronization object which helps for the interprocess synchronization between these processes~\cite[]{mssync}.\\
The sync object type covers all the synchronization activities.
\cite[]{mssync}.
\subsubsection{Driver}
\label{ssub:Driver}
A \emph{device driver } is a program that is associated with certain device for its operation and control. It is used as an software interface to communicate between the hardware device and the operating system and other software~\cite[Device Driver]{devicedriver} \\
Windows represent devices with device objects, and one device could be represented by more than one device objects. All operation on device is conducted via device object~\cite[]{msdevice}.\\
We capture those loading and unloading of Windows Device Driver recorded in the behavioral profile.\\

\textbf{Resource activities} in our work refers to operations, such as \emph{create, delete, modify, or access}, performed by a malware (program), on the resource types \emph{File, Registry, Service, Section, Process, Job, Sync, or Driver}, during its execution.
\textbf{Resource name} is same as object-name in \emph{OS-Objects}[\autoref{ssub:OS Objects}]---name of the resource created, modified, deleted, or accessed.
We use resource activities of malware samples to select the malware candidates that could exhibit behavioral interference [\autoref{sec:Initial Experiment}].
Further, resource activities related to malware were represented as \emph{``words''} related to \emph{``document''} (malware) to create a text corpora for document clustering [\autoref{sec:Document Clustering}].
% We will illustrate the implementation of resource activities in malware clustering in~\autoref{sec:Document Clustering}.
We describe the terms \emph{``words''}, \emph{``document''}, and \emph{``corpora''} in~\autoref{sub:Words, Document, Corpora}.
\subsection{Words, Document, Corpora}
\label{sub:Words, Document, Corpora}
% We have already discussed about using \emph{LDA} for clustering the malware in~\autoref{sec:Malware Clustering}, and what resource activities are in~\autoref{sub:Resource Types and Activities}.
In this section, we describe the terms \emph{``words''}, \emph{``document''}, and \emph{``corpora''} and how we associate, malware samples and resource activities, with those terms in our work.
The terms will be used extensively when describing clustering [\autoref{ssub:Latent Dirichlet Allocation}] and its implementation [\autoref{sec:Document Clustering}].
\subsubsection{Words}
\label{ssub:Words}
In their work,~\citeauthor{Blei}, describe word as, `A \emph{word} is a basic unit of discrete data, defined to be item from a vocabulary indexed by $\{1,\ldots,V\}$''~\cite[]{Blei}.\\
We represent a single resource activity of a malware as single word.
For an instance, a file creation activity will be a single distinct word and a file deletion activity will be another distinct word.
Same resource activity---with same resource type, resource name and operations---will be considered as repetition of same word.
For example, multiple registry keys created with same name by same or different malware.
\subsubsection{Document}
According to~\citeauthor{Blei}, ``a \emph{document} is a sequence of $N$ words denoted by $\textbf{w} = (w_1,w_2,\ldots,w_N)$, where $w_N$ is the $n$th word in the sequence''~\cite[]{Blei}.\\
A single malware sample will be represented as a single document and all the resource activities related to that malware will be the words in that document.
\label{ssub:Document}
\subsubsection{Corpora}
\label{ssub:Corpora}
``A \emph{corpus} is a collection of $M$ documents denoted by $D = \{w_1,w_2,\ldots,w_M\}$''~\cite[]{Blei}.\\
The total resource activities (words) related to all the malware samples (documents), in our dataset, will be our corpus.\\

\section{Work Flow}
\label{sec:Work Flow}
% In previous section, we described different terms we use in our work to help reader properly understand the usage of those terms.
In this section we outline an overview of our work flow.
Figure~\ref{fig:bigpicture} depicts the overall structure of of our system.\\
\subsection{Database}
\label{sub:Database}
We required resource activities of the malware samples, to process and find malware with behavioral interference.
We had access to the database that saved the analysis result of malware samples submitted to \emph{Anubis}.
It had resource activity of \emph{File, Registry, Mutex} for operations \emph{create, delete, modify, read}.
\\

However, the old database was missing the resource activities that were not successful, for an e.g., failed attempt to delete a file.
Anubis analyzed malware one at a time in total new OS environment; so the resources created during one analysis run were not present during the analysis run of another malware.
Because of this, malware trying to detect or delete the resource created by another malware would be unsuccessful.
A new database with record of such failed attempts was essential.\\

We used ``behavioral profile'' of malware sample, described in~\autoref{sub:Behavioral Profile}, to get both the successful and failed resource activities.
The ``behavioral profile'' of malware sample were parsed to get the resource name (object-name) and operations (operation-name) along with successful status, and was used to create new database.
The new database was created for the above discussed 8 types of resource (\emph{File, Registry, Service, Section, Job, Process, Job, Sync, and Driver}) and operations were generalized to \emph{modify, read, delete}.
The implementation is described in~\autoref{sec:Creation of Database}.

\subsection{Reverse Indexing}
\label{sub:Reverse Indexing}
After we created the database, we created reverse index of the resource activities.
The database had all the resource activities (failed and success) of the resource types: such as file created, file deleted, registry modified, registry accessed and so on.
We mapped `resource name', with all the malware, that had operations on that `resource name'.
For instance, we mapped the resource name of the \emph{files}, with all the malware that modified it.
Same reverse index was generated for read and delete operations, and for other resource types, \emph{registry} and \emph{mutex}.
With the reverse index, for each resource, we have a list of all the malware that modified, accessed, or deleted that resource.
We used the reverse index in our heuristics to select candidate malware pairs.
\subsection{Heuristics}
\label{sub:Heuristics}
We mapped reverse indexes, based on common resource name, to get malware set, say set \emph{`A'}, that created a resource \emph{`r'} with another malware set, say set \emph{`B'}, that tried to delete or read the same resource \emph{`r'}.
As described in~\autoref{sec:Malware Types and Families}, malware families have different ways of infecting and taking control of system, peculiar to themselves.
One can detect the presence of malware in the system, by checking the presence of unique resource (files, registries, and others) associated with that malware, in the system.
Thus, when a malware tries to access or delete some resource created by another malware (with a failed attempt because each malware was analyzed by Anubis in new OS environment), that activity is interesting for our candidate selection.\\

We selected malware sample from each of those set \emph{`A'} and \emph{`B'}, to get a candidate pair, with interference based on resource \emph{`r'}.
Large number of malware were present in each candidate set. A single resource name was created by tens of thousands of malware and being accessed by tens of thousands of another malware.
We had to lower the number of candidate set to get substantial number of good candidate pair.

% With the reverse index, we found the list of malware that created a resource, say \emph{`r'}, and another list of malware that read/modified/deleted the same resource \emph{`r'}.
% % After the reverse index was created, we mapped the create resource activity with read, modify, and delete activities.
% % As the result of the mapping we had list of malware that created a \textit{resource}, and a list of malware that either read/modify/delete the same \emph{resource}.
\subsection{Clustering}
\label{sub:Clustering}
We wanted to lower the size of candidate sets without loosing the quality of our dataset.
Malware variants belonging to same family, will have similar behavior pattern (code semantics) despite of code obfuscation.
We divide our dataset into different clusters (families), based on the similar resource activities.
Candidate pairs, with each malware in the pair from different family, trying to create/delete same resource has higher probability of behavioral interference than the previous heuristics.\\

% We did a literature survey of works on malware clustering, and found out that none of the works on large scale malware sample[see~\autoref{sec:Malware Clustering}].
Many previous research based on malware clustering were done for small number of malware samples [see~\autoref{sec:Malware Clustering}].
We needed an approach to cluster millions of malware samples.
We modeled malware clustering to \emph{document clustering} and used \emph{LDA} for its low memory footprint, $O(\#words\times \#clusters)$, compared to \emph{tf-idf}, $O(\#documents \times \#words)$.
\subsubsection{Latent Dirichlet Allocation}
\label{ssub:Latent Dirichlet Allocation}
%TODO: write about LDA
% -- write more about LDA --\\
A single resource activity---such as `file read', `registry delete' or `service modify'---would count as single \emph{`word'}.
All such resource activities of a single malware sample, is the total `words' in the single document (malware).
We created the corpus for document clustering with all the resource activities of all the malware dataset.
We gave each resource type, operation name, and resource name a unique numeric code to represent the resource activity as a word.
The number coding is given in~\autoref{lbl:numericode}
\begin{lstlisting}[numbers=none,language=python,caption={Numeric codes given to resource and operation},label={lbl:numericode}]
  RESOURCE_CODE    = {"file" : "1", "registry" : "2", "section" : "3", "service" : "4", "driver" : "5", "sync" : "6", "process" : "7", "job" : "8"}
  OPERATION_CODE   = {"access" : "1", "delete" : "2", "modify" : "3"}
\end{lstlisting}
So a file delete activity of filename, \textit{`c:\textbackslash\textbackslash{}gbot.exe'}, with \textit{file\_name\_id}, ``4986'' in our database, by some malware ``A'', would be represented as single word \emph{``1\_2\_4986''}.
\subsubsection{Gensim}
\label{ssub:Gensim}
\emph{``Gensim''}~\cite[]{gensim} is an efficient python library.
We preferred using it because of its simplicity, well documented API, and ability to work on large corpus.
We use the \emph{multicore}\cite[]{ldamulticore}  models for scalability.
Some of the benefits of using the \emph{ldamulticore} model were~\cite[]{ldamulticore}:
\begin{itemize}
\item The model utilized the multi cores processor of the machine efficiently with parallelization making the clustering process faster.
\item The training algorithm is streamed and we could feed the input documents sequentially even for large data.
\item The training algorithm runs in constant memory with respect to number of documents.
This made possible for us to process corpora that was larger than the memory size of our machine, as size of training corpus did not affect the memory footprint.
The maximum size of our corpus was 81 Gigabytes.

\end{itemize}
\subsection{Candidate Selection}
\label{sub:Candidate Selection}
% In this section we illustrate the heuristics for candidate selection process based on malware clustering.
The candidate selection steps, based on malware clustering, are summarized as follows:
\begin{itemize}
  \item Let, \emph{R}, be a set of candidate resources such that each resource ``r'' in \emph{R} have some malware set that create it (say set $A_r$) and some other set of malware that try to (unsuccessfully) access/delete it (say set $B_r$).
  \item Combine all such sets $A_r$ and $B_r$ corresponding to ``r'' in \emph{R} to sets \emph{A} and \emph{B}, respectively.
  \item Combine `A' and `B' and cluster them to cluster ids $[c_1,c_2,\ldots.\ c_n]$ (\emph{n} is number of family) such that any malware sample \emph{x} in (\emph{A} union \emph{B}) can be tagged/mapped to cluster id $C(x)$, where $C(x)$ belongs to $[c_1, c_2, \ldots c_n]$.
  \item For each ``r'' in \emph{R}, generate a set of candidate pairs $P_r$ for experiment. $P_r$ is a set of malware pairs $(x_r, y_r)$ such that $x_r$ belongs to $A_r$ and $y_r$ belongs to $B_r$ and $C(x_r) \neq C(y_r)$, not belonging to same cluster.
  \item Generate such $(x_r, y_r)$ pairs for all possible cluster pairs $(C(x_r), C(y_r))$ corresponding to a resource ``r''.
  \item The final experiment set \emph{E} is a set of such $(x_r, y_r)$ for all resources \emph{r} in \emph{R}.
  \item Finally for any resource ``r'', if the size of the set $| C(x) : x \in A_r | > n \quad or \quad | C(x) : x \in B_r | > n$, we discard \emph{r} and its corresponding experiment pairs from \emph{E}.
    The resource modified/deleted by too many families is less interesting.
    We choose \emph{`n'} accordingly to filter resource associated with too many families.
  % \item Here $(x,y)$ and $(y,x)$ will be different experiments because we run one sample, wait, and run another sample. Result can be different based on which one runs first.
\end{itemize}
\subsection{Running the Candidate}
\label{sub:Running the Candidate}
Our chosen dynamic analysis system [see \autoref{sub:Anubis}], \emph{Anubis}, analyzes only one binary at a time.
We created \emph{`packer'} and \emph{`unpacker'} to execute both malware of a candidate pair, packed together as single binary, with time interval in between two execution.
We used the fact that Windows PE executable loader works fine even with extraneous concatenated data at the end of valid executable file.
The \textbf{unpacker} is a self reading dropper binary.
With \textbf{Packer}, we attach the append binary of the candidate pair, to the back of \emph{unpacker} binary, one after another in sequence.
Followed by the binary, meta-information, such as size of both binary and preferred time delay, was appended to the end of the \emph{unpacker}.
We analyze the packed \emph{unpacker} binary in the \emph{Anubis}.
When executed, the \emph{unpacker}, would read itself from the behind to get the meta-information, and recreate the packed binaries, and drop them inside the \emph{Anubis} OS environment.
After both the binaries are dropped, it execute the first binary, waits for time delay specified, and runs another binary.
In the end, both the binary runs in the \emph{Anubis}, and we analyze the result.
In~\autoref{sec:packerunpacker}, we implement the \emph{packer} and \emph{unpacker}.
\subsection{Result Analysis}
\label{sub:Result Analysis}
\emph{Anubis}, generates result of analysis as \emph{Extensible Markup Language} (XML) format.
Every binary submitted to anubis is renamed into \emph{`sample.exe`}, and is considered as the primary analysis subject.
All the binaries created and executed, after the execution of primary analysis subject, is tracked for its malicious activities.
The XML report has the resource activities of each binaries presented under different XML node.\\
We are interested in `access/delete' activity of the `resource', based on which the candidate pair was chosen---`resource' created successfully by one malware, and failed attempt to access/delete the same resource by another.
Any successful access/delete of that resource (files or registries or others) will be the change in behavior of one malware caused by the presence of another malware.
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{figures/bigpicture.png}
  \caption[Big Picture]{Overview of the research and experiment}\label{fig:bigpicture}
\end{figure}
\section{Summary}
\label{sec:Summary}
In this chapter, we described different terms used in our work in details and also gave an overview of our work flow.
In next chapter, we will show how we implemented the work flow in our system.
